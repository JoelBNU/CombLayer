%\section{HowTo}
\begin{itemize}
\item Get real surface number by its relative number: SMap.realSurf(divIndex+103) (see createLinks methods)
\end{itemize}

\subsection{How to use FrontBackCut}
{\tt FrontBackCut} is an object which joins things together, i.e. fills space between two links (front and back).
For instance, the pillars of the bunker are FrontBackCut.
It's not always the whole object, it can be a part of an object.

If you have a front-back cut, you can do setFront and setBack. There are two ways to use it:
\begin{enumerate}
\item when you want to define your own surface. Normally you would use it like FC+LinkPoint, or even + BridgeSurface.
  You can give him surface number or even string, or link point. The method sorts all out.
  It does the link points by going to the origin and projects the axis back until it intersects the object.
\item easyActive: sometimes you do not really know if you will have a front-back cutting device. So, it can build the cut depending if it is needed.
  You need to set the active flag appropriately.
\end{enumerate}
There are plenty examples in the CL source code. You can also set only front or only back.
If it can be joint, you add it, if you do not use it~--- not a big deal.


\subsection{Activation}
Old way: {\tt -cinder}. But you have to worry about individual cells, which is inconvenient.

New (and significantly improved) way: {\tt -activation}.
You need to run the cinder script two times: once to get a flux; and once you have a flux, you can run {\tt activation} to make the gamma source for you.

\subsubsection{Flux}
To run flux is easy:
\begin{bash}
./prog -r -T flux n AllNonVoid BeRef Output
\end{bash}
material can be material name, ``All'' or ``AllNonVoid'' (flux for activation in a void cell is pointless).
It adds the {\tt f4} tally with energy binning for \cinder:

\begin{mcnp}
f4:n ( 3 4 5 6 7 )
fq4   e f
fc4 tally: 4 mat : -2:BeRef
e4    1e-11 5e-09 5i 3.5e-08 4.2e-08 5e-08 5.8e-08 6.7e-08 8e-08 1e-07
        1.52e-07 2.51e-07 4.14e-07 6.83e-07 1.125e-06 1.855e-06
        3.059e-06 5.043e-06 8.315e-06 1.371e-05 2.26e-05 3.727e-05
        6.144e-05 0.0001013 0.000167 0.0002754 0.000454 0.0007485
        0.001234 0.002035 0.002404 0.00284 0.003355 0.005531 0.009119
        0.01503 0.01989 0.02554 0.04087 0.06738 0.1111 0.1832 0.302
        0.3887 0.4979 0.639279 0.82085 1.10803 1.35335 1.73774 2.2313
        2.86505 3.67879 4.96585 6.065 10 14.9182 16.9046 20 25
\end{mcnp}

If you {\em really} having a bad day, you can write:
\begin{bash}
./prog -r -T flux n AllNonVoid All Output
\end{bash}
to get flux in all non-void cells of the model.

When we are running \cinder in a normal way, we calculate flux in the given material (but not in all non-void cells).
That's because we have to go through the \cinder system, while with CombLayer you do not have this limitation.


\subsection{How to put one object into another}

Suppose, we are inserting Spoon into Mug.
Mug is made up of N cells. Spoon is made of one contained component with outer surface.
CombLayer provides several methods to put one object into another:

\begin{lstlisting}[language=C++]{Name=essBuild}{floatplacement=H}
attachSystem::addToInsertForced(System,   *Mug, *Spoon);
attachSystem::addToInsertSurfCtrl(System, *Mug, *Spoon);
attachSystem::addToInsertControl(System,  *Mug, *Spoon);
attachSystem::addToInsertLineCtrl(System, *Mug, *Spoon);
\end{lstlisting}

\subsubsection{addToInsertForced}
The outer surface of the Spoon is excluded from the HeadRule of every single cell of Mug.
Even if Mug contains cells which do not intersect with Spoon (e.g. its handle).
``Forced'' means ``do it and do not think about it'', but at the same time it means that ``I have got something wrong somewhere in my mental thinking''.

\subsubsection{addToInsertSurfCtrl}
First, it deconvolves Mug into its surfaces.
Then for each cell of Mug it calculates intersections between all surfaces of this cell and all surfaces of Mug.
The Mug is inserted only into those cells of Mug which it intersects.

It is not always better to call {\tt addToInsertSurfCtrl} instead of {\tt addToInsertForced}. \alert{Example needed.}

{\tt addToInsertSurfCtrl} is a very expensive function to call, because you have to check all the surface triplets. So, it runs a bit slower than addToInsertForced, but the geometry will be faster.
However, there is another method which provides the same trick for less pain.

\subsubsection{addToInsertControl}
It's a very simple method. Spoon has to have the link points defined.
The method checks if any of these link point fit inside the outer surface of Mug. If it does, then it cuts Spoon from the Mug.
It is possible to add a vector of link points to check as a parameter.

\subsubsection{addToInsertLineCtrl}
Imagine we have a (big) contained component~(Mug) and some (small) object which clips it~(Spoon). The link points are {\bf not} in the Mug~(therefore {\bf addToInsertControl} can not be used), but the lines which connect them are in the Mug.
The method checks the lines connecting the link points and sorts out the intersections.

\subsection{Void cell number}
When SA first arrived at ISIS, he took some input files from other people, and from their numbering system the supervoid cell had this number.
You would not allowed to put anything in that cell. In CombLayer no cells can have a number in 74xxx range (before renumbering).

\subsection{DBCN card}
He set it manually because he wants random sequence starting with a very small number, and the 2nd number to be very large.
He printed 10-20 random sequences and the one which fitted this idea was the one with that seed.
He wants it because in this way you can get source points which are ``averaged'' conditions.